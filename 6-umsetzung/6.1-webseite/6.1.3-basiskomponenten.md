# 6.1.3 Basiskomponenten

In diesem Kapitel sollen exemplarisch die Basiskomponenten und Pages zur Anzeige und Suche/Filterung der Dateien und deren Zusammenhang zueinander gezeigt werden. Der einzig wesentliche Unterschied zwischen Pages und Komponenten in Blazor ist, dass Pages eine oder mehrere (eindeutige) Routen haben, über welche Parameter (nur Primitives) übergebn werden können. Komponenten werden hingegen von anderen Komponenten oder Pages genutzt und die Parameter direkt an diese Übergeben. Ansonsten ist der Aufbau wie in Kapitel [4.4-framework-spezifika](../../4-entwicklungsumgebung/4.4-framework-spezifika/ "mention") beschrieben gleich. Die Komponenten/Pages sind:

* FileGrid (Page)
* FileCardPreview (Komponente)
* SearchBar (Komponente)
* FileAccessFilter (Komponente)
* FileCard (Page)
* FilesGridViewModel (C# Klasse)

Das Filegrid bildet den Einstiegspunkt für die Anzeige der Dateien. Es zeigt in einer ersten Übersicht die Dateinamen, den Autor, die Gesamtbwertung und ein Vorschaubild. Die Dateien können nach Namen durchsucht und nach öffentlichen und privaten Dateien gefiltert werden. Ein Klick auf eines der Bilder führt zur Detailansicht.

### FileGrid

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Im Codebehind wird das Callback des Viewmodels registriert, welches ausgelöst wird, wenn die Abfrage des FileRepositories beendet ist und die Informationen für die Dateien zur Verfügung stehen (Zeile 16 bis 17). Ein weiteres Event bei einem Klick auf ein Bild routet zur FileCard Page und übergibt dieser die Id der Datei (Zeile 21).

{% code title="FileGrid.razor.cs" lineNumbers="true" %}
```csharp
public partial class FileGrid
{
    [Inject]
    private NavigationManager NavigationManager { get; set; }

    [Inject]
    public IFilesGridViewModel Vm { get; set; }
    
    protected override async Task OnAfterRenderAsync(bool isFirstRender)
    {
        if (isFirstRender)
        {
            Vm.FilesChanged = EventCallback.Factory
                .Create(this, async () => await InvokeAsync(StateHasChanged));
            await Vm.Init(UserId);
        }
    }
    
    private void OnButtonClicked(string fileId)
    {
        NavigationManager.NavigateTo($"/model/{fileId}");
    }
}
```
{% endcode %}

Im Markup der Komponente ist gut der Aufruf weiterer eigener Komponenten mit Übergabe der Parameter zu sehen (Zeile 7, 13, 26). In Zeile 28 ist zu sehen wie das Callback der Komponente (der jeweils einzelnen Vorschau) registriert wird und an den (diesen) Parent delegiert wird.

{% code title="FileGrid.razor" lineNumbers="true" %}
```html
@attribute [Authorize]
<MudContainer MaxWidth="MaxWidth.Large">
    <MudText Style="padding-top: 50px;" Typo="Typo.h2"> 
    @Localization.PagesIndexTitle</MudText>
    <div style="width: 100%; display: flex;">
        <div style="width: 100%; margin-right: 20px; ">
            <SearchBar 
                Search="@Vm.UpdateFilteredFiles" 
                SelectedSearchValue="@Vm.SelectedSearchValue" />
        </div>
        <div style="display: flex; flex-direction: row-reverse; align-items: 
                flex-end; gap: 10px"> 
            <FileAccessFilter 
                FiletypeHasChanged="async f =>  await Vm.UpdateFilteredFiles(f)"
                Status="Vm.FileAccessStatus"
            />
        </div>
    </div>
    <MudGrid Style="margin-top: 25px;">
        @foreach (var file in Vm.FilteredFiles)
        {
            <MudItem xs="3" Style="padding: 0; margin: 0;">
                <MudContainer
                    Style="padding: 0; margin: 0;"
                    Class="d-flex align-center justify-center mud-width-full">
                    <FileCardPreview
                        File="@file"
                        ButtonClicked="OnButtonClicked"/>
                </MudContainer>
            </MudItem>
        }
    </MudGrid>
</MudContainer>
```
{% endcode %}

Das ViewModel soll hier nur exemplarisch anhand einer Funktion gezeigt werden, welche im Codebehind zu Beginn des Lifecycles aufgerufen wird um den Http Request ans Backend zu initiliasieren.

{% code title="FilesGridViewModel.cs" overflow="wrap" %}
```csharp
 public async Task Init(string userId)
{
    _userId = userId;
    var files = await _fileRepository.GetAll($"user/{_userId}");
    _files = new List<FileModel>(files);
    FilteredFiles = new List<FileModel>(_files);
    await FilesChanged.InvokeAsync();
}
```
{% endcode %}

### FileCardPreview

Die Komponente bildet eine einzelne Kachel im Filegrid ab und benötigt lediglich eine Instanz der Klasse File. Zudem exposed sie das oben erwähnte Callback, damit die Parentkomponente an die jeweilige Seite weiterleiten kann. Dies hätte auch direkt in der Komponente erfolgen können, hätte aber dazu geführt, dass eine weitere Abhängigkeit eingeführt worden wäre (NavigationManager). So bleibt die Komponente (relativ) generisch. &#x20;

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

{% code title="FileCardPreview.razor.cs" lineNumbers="true" %}
```csharp
public partial class FileCardPreview
{
    [Parameter] 
    public FileModel File { get; set; }
    
    [Parameter] 
    public EventCallback<string> ButtonClicked { get; set; }
}
```
{% endcode %}

{% code title="FileCardPreview.razor" lineNumbers="true" %}
```html
<MudButton
    Color="Color.Transparent" 
    Variant="Variant.Text" 
    Style="width: 100%; height: 100%" 
    OnClick="() => ButtonClicked.InvokeAsync(File.Id)">
    <MudCard Style="width: 100%;">
        <MudCardHeader Style="padding: 6px;">
            <CardHeaderContent>
                <MudText
                    Typo="Typo.h6">
                    @File.FullName
                </MudText>
            </CardHeaderContent>
        </MudCardHeader>
        <MudCardContent Style="padding-top: 0; padding-bottom: 0;">
            <MudCardMedia
                    Image="@($"previewfiles/{File.FullName}.png")"
                    Style="min-height: 240px; height: 100%; width: 100%; border-style: solid; border-width: 1px; border-radius: 4px; border-color: #f0f8ff36;"/>
            <MudGrid>
                <MudItem xs="12" sm="6">
                    <MudText Class="mud-width-full py-4 d-flex align-center justify-start">
                        @File.Owner
                    </MudText>
                </MudItem>
                <MudItem xs="12" sm="6">
                    <MudRating
                        Class="mud-width-full py-4 d-flex align-center justify-end"
                        ReadOnly="true"
                        SelectedValue="@Convert.ToInt32(File.AverageRating)"/>
                </MudItem>
            </MudGrid>
        </MudCardContent>
    </MudCard>
</MudButton>    
```
{% endcode %}

### SearchBar

Dies ist eine weitere Komponente die vom FileGrid aufgerufen wird. Außer einem Delegaten welcher den Aufruf der Suche über den Parent an das Viewmodel weitergibt und dem Parameter mit dem Suchstring passiert hier nicht viel. MudAutoComplete ist wie alle mit Mud geprefixten Komponenten eine Standardkomponente der verwendeten UI-Komponentenbibliothek MudBlazor.

{% code lineNumbers="true" %}
```csharp
public partial class SearchBar
{
    [Parameter] 
    public string SelectedSearchValue { get; set; }

    [Parameter]
    public Func<string, Task<IEnumerable<string>>> Search { get; set; }
}
```
{% endcode %}

{% code lineNumbers="true" %}
```html
<MudAutocomplete
    T="string" 
    Immediate="true"
    Label="@Localization.ComponentsSearchBarLabel"
    @bind-Value="SelectedSearchValue" 
    AdornmentIcon="@Icons.Material.Filled.Search" 
    AdornmentColor="Color.Primary"
    SearchFunc="Search"/>
```
{% endcode %}
